---
layout: post
category: http
title: "para.rs"
---

<small>この文章はAIで生成しています。誤りが含まれることがあります。</small>

このRustプログラムは、非同期でHTTPリクエストを送信し、レスポンスの本文を取得することを目的としたアプリケーションです。以下にその詳細な説明を記載します。

このプログラムは、`reqwest`クレートを使用して非同期HTTPリクエストを行います。`tokio`クレートは非同期処理をサポートするためのランタイムを提供します。`fetch`関数は、与えられたURLに対してHTTP GETリクエストを送信し、レスポンスの本文を文字列として返します。`main`関数では、`tokio::join!`マクロを使用して複数の非同期タスクを並行して実行し、各URLに対するリクエストを同時に送信します。各リクエストのレスポンスのサイズを出力します。

このプログラムは、非同期処理の効率的な実装を目指しています。`tokio::join!`マクロは、複数の非同期タスクを並行して実行し、結果を待つことで、リソースの利用を効率的にしています。また、`reqwest`クレートは非同期HTTPリクエストを扱うための高水準のインターフェースを提供しています。

このプログラムは、Rustの非同期プログラミングの基本的な概念を理解するための良い例です。非同期処理は、I/Oバウンドなタスク（ネットワークリクエストなど）を効率的に処理するために重要です。`tokio`と`reqwest`は、Rustで非同期プログラミングを実現するための強力なツールです。

```rust
use reqwest::Client;
use tokio;

async fn fetch(client: &Client, url: &str) -> Result<String, reqwest::Error> {
    let res = client.get(url).send().await?;
    let body = res.text().await?;
    Ok(body)
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let client = Client::new();

    let url1 = "http://localhost/";
    let url2 = "http://localhost/";
    let url3 = "http://localhost/";

    let (r1, r2, r3) = tokio::join!(
        fetch(&client, url1),
        fetch(&client, url2),
        fetch(&client, url3),
    );

    println!("site1: {} bytes", r1?.len());
    println!("site2: {} bytes", r2?.len());
    println!("site3: {} bytes", r3?.len());

    Ok(())
}

```
